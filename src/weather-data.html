<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">

<dom-module id="weather-data">

  <!-- TODO: WeatherSymbol3 TotalCloudCover  -->
  <template>
    <iron-ajax
      id="weather"
      url="https://data.fmi.fi/fmi-apikey/412facb5-f1bc-44e7-88cc-dc9e08903e32/wfs",
      params="{{_getParams(weatherLocation)}}",
      handle-as="document"
      on-response="_handleResponse"></iron-ajax>
  </template>

  <script>
    /**
     * Fetching the weather data from the server
     */
    class WeatherData extends Polymer.Element {
      static get is() { return 'weather-data'; }
      
      static get properties() {
        return {
          latlon: {
            type: Number,
            computed: '_latlon(weatherLocation)'
          },

          place: {
            type: Number,
            computed: '_place(weatherLocation)'
          },

          weatherLocation: {
            type: Object,
            observer: '_newLocation'
          },

          /**
           * Example:
           * {
           *  temperature: '6,5'
           * }
           */
          weatherNowData: {
            type: Object,
            notify: true
          },

          /**
           * Example:
           * {
           *  time: '2018-01-07T10:00:00Z',
           *  temperature: 6
           * }, 
           * {...}
           */
          weatherData: {
            type: Array,
            notify: true
          },
        };
      }

      // Lifecycle functions

      ready() {
        super.ready();
      }

      
      // other functions alphabetically
    
      _combine(temperature, symbol, rain, wind, windDirection) {
        
        let weatherJson = [];

        for (let i = 0; i < temperature.length; i++) {
          weatherJson.push(
            { 
              "time": this._get(temperature[i], true),
              "temperature": this._get(temperature[i]),
              "symbol": this._get(symbol[i]),
              "rain": this._get(rain[i]),
              "wind": this._get(wind[i]),
              "windDirection": this._get(windDirection[i])
            });
        };

        return weatherJson;
      }

      _get(item, time) {
        return time 
          ? this._value(item.children[0]) 
          : parseFloat(this._value(item.children[1]));
      }

      _getByAttributeValue(collection, attribute, value) {
        for (let item of collection) {
          if(item.getAttribute(attribute) === value){
            return item;
          }
        }
      }

      _getParams(location){

        let params = 
        {
          "request":"getFeature", 
          "storedquery_id":"fmi::forecast::hirlam::surface::point::timevaluepair",
          "parameters": "Temperature,WeatherSymbol3,Precipitation1h,WindDirection,WindSpeedMS",
          "starttime": this._todayFirstHour(),
          "endtime": this._tomorrowLastHour(),
          

        }

        location.place == null 
          ? params.latlon = location.latlon
          : params.place = location.place


        return params;
      }

      _getTimeAndValuePairs(sourceXml, attributeName, name) {
        const measurementTVPs = this._getByAttributeValue(sourceXml, 'gml:id', attributeName)
          .getElementsByTagName('wml2:MeasurementTVP')

        return measurementTVPs;
      }

      _getWeatherNow(data) {
        let timeNow = new Date();
        timeNow.setMinutes(0,0,0);
        
        const timeISO = timeNow.toISOString().split('.')[0]+"Z";

        return data.filter(function (item) {
          return item.time === timeISO;
        });
      }
      
      /**
       * Data comes from the following format from FMI open API
       * 
       *	...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-Temperature">
			 *		<wml2:point>
		 	 *			<wml2:MeasurementTVP>
			 *				<wml2:time>2018-01-09T20:00:00Z</wml2:time>
			 *				<wml2:value>-2.41</wml2:value>
       *  ...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-WeatherSymbol3">
			 *		...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-Precipitation1h">
			 *    ...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-WindSpeedMS">
       *    ...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-WindDirection">
       * 
       * 
       * And it is converted to the following JSON and stored into this.weatherData 
       * 
       * [
       *    {hour:1, rain: NaN, symbol: NaN, temperature: NaN, time: "2018-03-02T23:00:00Z", wind: NaN, windDirection: NaN}
       *    {hour:2, ...}
       * ]
       */
       _handleResponse(event, request) {
        const place = this._parseLocation(request.response);
      
        var newPlace = new CustomEvent('weather-data.new-place', {detail: { place: place}, bubbles: true, composed: true});
        this.dispatchEvent(newPlace);
        
        const timeSeries = request.response.getElementsByTagName('wml2:MeasurementTimeseries');

        const temperature = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-Temperature', 'temperature');
        const symbol = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-WeatherSymbol3', 'symbol');
        const rain = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-Precipitation1h', 'rain');

        const wind = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-WindSpeedMS', 'wind');
        const windDirection = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-WindDirection', 'windDirection');

        this.weatherData = this._combine(temperature, symbol, rain, wind, windDirection);

        this.weatherData.forEach( element => {
          element.hour = this._toHour(element.time);
        });
        
        this.weatherNowData = this._getWeatherNow(this.weatherData)[0];
      }


      _latlon (location) {
        return location.latlon; 
      }

      _newLocation() {
        this.$.weather.params = this._getParams(this.weatherLocation);
        this.$.weather.generateRequest();
      }

      /* <gml:name codeSpace="http://xml.fmi.fi/namespace/locationcode/name">Kattilalaakso</gml:name> */
      _parseLocation(response){
        const locations = response.getElementsByTagName('gml:name');

        const locationRow = this._getByAttributeValue(locations, 'codeSpace', 'http://xml.fmi.fi/namespace/locationcode/name');
        const location = this._value(locationRow);

        return location;
      }

      _parseWeatherNow(temperature, symbols){
        const temperatureRaw = this._value(temperature[0].children[1]);
        
        const symbol = Math.round(this._value(symbols[0].children[1]));

        const weatherNow = {
          temperature: temperatureRaw,
          symbol: symbol
        };

        return weatherNow;
      }

      _place (location) {
        return location.place; 
      }

      _todayFirstHour() {
        
        let firstHour = new Date();
        firstHour.setHours(0,0,0,0);
        console.log('first hour' + firstHour.toISOString());
        return firstHour.toISOString();
      }

      _toHour(time){
        
        if (typeof time === 'number'){
          return time;
        }
        console.log('aika ' +time);
        const dateObject = new Date(time);

        let hour = dateObject.getHours(); 
        console.log('tunti ' + hour)
        return hour === 0 ? 24 : dateObject.getHours();
      }

      _tomorrowLastHour() {
        const now = new Date();

        let tomorrow = new Date()
        tomorrow.setDate(now.getDate() + 2);
        tomorrow.setHours(24,0,0,0);

console.log('last hour' + tomorrow.toISOString());
        return tomorrow.toISOString();
      }

      _value(xmlElement) {
        return xmlElement.childNodes[0].nodeValue;
      }
    }

    window.customElements.define(WeatherData.is, WeatherData);
  </script>
</dom-module>
