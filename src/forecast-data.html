<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">

<dom-module id="forecast-data">

  <!--  Fetch weather forecast from Ilmatieteenlaitos. Prefer "Harmonie" model
        and do another call against Hirlam to get weather symbol and rain that are 
        missing from Harmonie -->
  <template>
    <iron-ajax
      id="weatherHarmonie"
      url="https://data.fmi.fi/fmi-apikey/412facb5-f1bc-44e7-88cc-dc9e08903e32/wfs",
      params="{{_getParams(weatherLocation)}}",
      headers="{'Cache-Control': 'no-cache'}",
      handle-as="xml">
    </iron-ajax>

    <iron-ajax
      id="weatherHirlam"
      url="https://data.fmi.fi/fmi-apikey/412facb5-f1bc-44e7-88cc-dc9e08903e32/wfs",
      params="{{_getHirlamParams(weatherLocation)}}",
      headers="{'Cache-Control': 'no-cache'}",
      handle-as="xml">
    </iron-ajax>
  </template>

  <script>
    /**
     * Fetching the weather data from the server
     */
    class ForecastData extends Polymer.Element {
      static get is() { return 'forecast-data'; }
      
      static get properties() {
        return {
          latlon: {
            type: Number,
            computed: '_latlon(weatherLocation)'
          },

          place: {
            type: Number,
            computed: '_place(weatherLocation)'
          },

          weatherLocation: {
            type: Object,
            observer: '_newLocation'
          },

          /**
           * Example:
           * {
           *  temperature: '6,5'
           * }
           */
          weatherNowData: {
            type: Object,
            notify: true
          },

          /**
           * Example:
           * {
           *  time: '2018-01-07T10:00:00Z',
           *  temperature: 6
           * }, 
           * {...}
           */
          forecastData: {
            type: Array,
            notify: true
          },
        };
      }

      // Lifecycle functions

      ready() {
        super.ready();
      }

      
      // other functions alphabetically
    
      _combine(humidity, rain, symbol, temperature, wind, windDirection) {
        
        let weatherJson = [];

        for (let i = 0; i < temperature.length; i++) {
          weatherJson.push(
            { 
              "humidity": this._get(humidity[i]),
              "rain": this._get(rain[i]),
              "symbol": this._get(symbol[i]),
              "time": this._get(temperature[i], true),
              "temperature": this._get(temperature[i]),
              "wind": this._get(wind[i]),
              "windDirection": this._get(windDirection[i])
            });
        };

        return weatherJson;
      }

      _combineDatas(harmonie, hirlam) {
        let combinedData = this._combine(harmonie.humidity, hirlam.rain, hirlam.symbol, harmonie.temperature, harmonie.wind, harmonie.windDirection);

        combinedData.forEach( element => {
          element.hour = this._toHour(element.time);
        });

        return combinedData;
      }


      _feelsLike(t, v) {
        let feelsLike3 = 13.12 + 0.6215*0.80 - 13.956*Math.pow(5, 0.16) + 0.4867*0.80*Math.pow(5,0.16)
      }

      _get(item, time) {
        return time 
          ? this._value(item.children[0]) 
          : parseFloat(this._value(item.children[1]));
      }

      _getByAttributeValue(collection, attribute, value) {
        for (let item of collection) {
          if(item.getAttribute(attribute) === value){
            return item;
          }
        }
      }

      _getParams(location){
  
        let params = 
        {
          "request":"getFeature", 
          "storedquery_id":"fmi::forecast::harmonie::surface::point::timevaluepair",
          "parameters": "Humidity,Temperature,WindDirection,WindSpeedMS",
          "starttime": this._todayFirstHour(),
          "endtime": this._tomorrowLastHour(),
        }

        location.place == null 
          ? params.latlon = location.latlon
          : params.place = location.place


        return params;
      }

       _getHirlamParams(location){
       
        let params = 
        {
          "request":"getFeature", 
          "storedquery_id":"fmi::forecast::hirlam::surface::point::timevaluepair",
          "parameters": "Precipitation1h,WeatherSymbol3",
          "starttime": this._todayFirstHour(),
          "endtime": this._tomorrowLastHour(),
        }

        location.place == null 
          ? params.latlon = location.latlon
          : params.place = location.place


        return params;
      }

      _getTimeAndValuePairs(sourceXml, attributeName, name) {
        const measurementTVPs = this._getByAttributeValue(sourceXml, 'gml:id', attributeName)
          .getElementsByTagName('wml2:MeasurementTVP')

        return measurementTVPs;
      }

      _getWeatherNow(data, time) {
        return data.filter(function (item) {
          return item.time === time;
        });
      }
      
      /**
       * Data comes from the following format from FMI open API
       * 
       *	...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-Temperature">
			 *		<wml2:point>
		 	 *			<wml2:MeasurementTVP>
			 *				<wml2:time>2018-01-09T20:00:00Z</wml2:time>
			 *				<wml2:value>-2.41</wml2:value>
       *  ...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-WeatherSymbol3">
			 *		...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-Precipitation1h">
			 *    ...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-WindSpeedMS">
       *    ...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-WindDirection">
       *    ...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-Humidity">  
       * 
       * 
       * And it is converted to the following JSON and stored into this.forecastData 
       * 
       * [
       *    {hour:1, rain: NaN, symbol: NaN, temperature: NaN, time: "2018-03-02T23:00:00Z", wind: NaN, windDirection: NaN}
       *    {hour:2, ...}
       * ]
       */
       _harmonieResponse(response) {

        const timeSeries = response.getElementsByTagName('wml2:MeasurementTimeseries');
        
        let harmonieResponse = {};

        harmonieResponse.humidity = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-Humidity', 'humidity');
        harmonieResponse.temperature = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-Temperature', 'temperature');
        harmonieResponse.wind = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-WindSpeedMS', 'wind');
        harmonieResponse.windDirection = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-WindDirection', 'windDirection');
        
        return harmonieResponse;
      }

      _hirlamResponse(response) {
      
        const timeSeries = response.getElementsByTagName('wml2:MeasurementTimeseries');
        
        let hirlamResponse = {};

        hirlamResponse.rain = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-Precipitation1h', 'rain');
        hirlamResponse.symbol = this._getTimeAndValuePairs(timeSeries, 'mts-1-1-WeatherSymbol3', 'symbol');
        
        return hirlamResponse;
      }

      _latlon (location) {
        return location.latlon; 
      }

      /** 
       *trigger call to get hirlam and harmonie weather data
       */
      _newLocation() {
        const harmonieRequest = this._prepareRequest('weatherHarmonie', this._getParams(this.weatherLocation));
        const hirlamRequest = this._prepareRequest('weatherHirlam', this._getHirlamParams(this.weatherLocation));

        Promise.all([harmonieRequest.completes, hirlamRequest.completes])
          .then((values) => {
            this._sendNotification(this._parseLocation(values[0].response));
            
            const harmonieResponse = this._harmonieResponse(values[0].response);
            const hirlamResponse = this._hirlamResponse(values[1].response);

            this.forecastData = this._combineDatas(harmonieResponse, hirlamResponse);
            this.weatherNowData = this._getWeatherNow(this.forecastData, this._timeNow())[0];
          });
      }

      _sendNotification(location) {
        var newPlace = new CustomEvent('forecast-data.new-place', {detail: { place: location}, bubbles: true, composed: true});
        this.dispatchEvent(newPlace);
      }

      _prepareRequest(id, params){
        this.$[id].params = params;
        return this.$[id].generateRequest();
      }


      /* <gml:name codeSpace="http://xml.fmi.fi/namespace/locationcode/name">Kattilalaakso</gml:name> */
      _parseLocation(response){
        const locations = response.getElementsByTagName('gml:name');

        const locationRow = this._getByAttributeValue(locations, 'codeSpace', 'http://xml.fmi.fi/namespace/locationcode/name');
        const location = this._value(locationRow);

        return location;
      }

      _parseWeatherNow(temperature, symbols){
        const temperatureRaw = this._value(temperature[0].children[1]);
        
        const symbol = Math.round(this._value(symbols[0].children[1]));

        const weatherNow = {
          temperature: temperatureRaw,
          symbol: symbol
        };

        return weatherNow;
      }

      _place (location) {
        return location.place; 
      }

      _timeNow(){
        let timeNow = new Date();

        timeNow.setMinutes(timeNow.getMinutes() + 30);
        timeNow.setMinutes(0,0,0);

        return timeNow.toISOString().split('.')[0]+"Z";
      }


      _todayFirstHour() {
        
        let firstHour = new Date();
        firstHour.setHours(1,0,0,0);
      
        return firstHour.toISOString();
      }

      _toHour(time){
        
        if (typeof time === 'number'){
          return time;
        }

        const dateObject = new Date(time);
        let hour = dateObject.getHours(); 

        return hour === 0 ? 24 : dateObject.getHours();
      }

      _tomorrowLastHour() {
        const now = new Date();

        let tomorrow = new Date()
        tomorrow.setDate(now.getDate() + 2);
        tomorrow.setHours(24,0,0,0);

        return tomorrow.toISOString();
      }

      _value(xmlElement) {
        return xmlElement.childNodes[0].nodeValue;
      }
    }

    window.customElements.define(ForecastData.is, ForecastData);
  </script>
</dom-module>
