<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/paper-fab/paper-fab.html">

<dom-module id="location-selector">
  <template>

    <style>
      :host {
        display: block;
        color: var(--color-black);
        font-size: 1.563rem;
        
        margin: 0 0 0.2rem 0;
	    	text-align: center;	    
      }

      .locate {
        display: flex;
      }

      .locate_icon {
        vertical-align: middle;

        padding: 0 0.6rem;
        margin-left: 1rem;
      }

      .locate_text {
        color: var(--color-white);
        font-size: var(--font-size-small);
      }

      .location_name {
        padding-right: 2rem;
      }

      .floating_locate {
        position: fixed;
        right: 3rem;
        bottom: 4rem;
        z-index: 3;
      }

    </style>
    
    <div class="locate" on-click="_geolocate">
      <div class="locate_icon">
        
        <svg xmlns="http://www.w3.org/2000/svg" fill="#fff" width="28" height="28" viewBox="0 0 24 24">
          <filter id="dropshadow" height="130%">

            <feGaussianBlur in="SourceAlpha" stdDeviation="1"></feGaussianBlur> <!-- stdDeviation is how much to blur -->
            <feOffset dx="0" dy="1" result="offsetblur"></feOffset> <!-- how much to offset -->
            <feComponentTransfer>
              <feFuncA type="linear" slope="0.5"></feFuncA> <!-- slope is the opacity of the shadow -->
            </feComponentTransfer>
  
            <feMerge>        
              <feMergeNode></feMergeNode> <!-- this contains the offset blurred image -->
              <feMergeNode in="SourceGraphic"></feMergeNode> <!-- this contains the element that the filter is applied to -->
            </feMerge>
  
          </filter>

          <path style="filter:url('#dropshadow')" d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
        </svg>
        <!-- div class="locate_text">paikanna</div -->
      </div>

      <div class="location_name">[[placeName]] nyt</div>
    </div>

  </template>

  <script>

    /**
     * @customElement
     * @polymer
     */
    class LocationSelector extends Polymer.Element {
      static get is() { return 'location-selector'; }
      
      static get properties() {
        return {
          place: {
            type: Object,
            value: undefined,
            observer: '_pushToHistory'
          },
          defaultPlace: {
            type: String,
            value:  '658225' // helsinki
          },
          placeName: {
            type: String,
            computed: '_getPlace(place)'
          }
        };
      }

      ready() {
	      super.ready();
        
        const urlPlace = this._getUrlParams('place', window.location.href) 
          ? this._getUrlParams('place', window.location.href)
          : this.defaultPlace;
        
        this._dispatchEvent('location-selector.new-location', {place: urlPlace});
      } 
      

      /**
       * @return whether response API is supported
       */

      _responseApi() {
        return  navigator.permissions;
      }


      /**
       * @return whether location is already allowed and can be used without 
       * showing pop up to user
       */

      _locationAlreadyAllowed() {
        return new Promise(function(resolve, reject){
          if(!this._responseApi()) {
            reject;
          }
          else {
            navigator.permissions.query({name:'geolocation'})
              .then(permission => 
                permission.state === "granted" ? resolve : reject
              );
          }

        });
      }

      _getUrlParams(name, url) {
        name = name.replace(/[\[\]]/g, "\\$&");
        
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
            results = regex.exec(url);
        if (!results) {
          return null;
        }
        if (!results[2]) { 
          return '';
        }

        return decodeURIComponent(results[2].replace(/\+/g, " "));
      }

      _getPlace(placeName) {
     
        if(placeName && placeName.location){
          return placeName.location.name;
        }

        return '';
        
      }

      _pushToHistory() {
        history.replaceState(null, null, "?" + 'place=' + this.place.location.geoid);
      }

      _geolocate() {
    
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              position => {
          
                const latlon = position.coords.latitude + ',' + position.coords.longitude;

                this._dispatchEvent('location-selector.new-location', { latlon: latlon});

              }, error => {
                this._dispatchEvent('location-selector.locate-error', {text: 'salli paikannus nähdäksesi paikkakuntasi sää'});
              });
        } 
        else { 
          this._dispatchEvent('location-selector.locate-error', {text: 'paikantaminen epäonnistui, yritä uudelleen'});
        }
      }  

      _dispatchEvent(name, payload) {
        const event = new CustomEvent(name, {detail: payload, bubbles: true, composed: true});
          this.dispatchEvent(event);
      }
    }

    window.customElements.define(LocationSelector.is, LocationSelector);
  </script>
</dom-module>
