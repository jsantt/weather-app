<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">

<dom-module id="saa-data">

  <!-- TODO: WeatherSymbol3 TotalCloudCover  -->
  <template>
    <iron-ajax
      id="weather"
      url="https://data.fmi.fi/fmi-apikey/412facb5-f1bc-44e7-88cc-dc9e08903e32/wfs",
      params="{{_getParams(weatherLocation)}}",
      handle-as="document"
      on-response="_handleResponse"></iron-ajax>
  </template>

  <script>
    /**
     * `saa-data`
     * Fetching the weather data from the server
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class SaaData extends Polymer.Element {
      static get is() { return 'saa-data'; }
      static get properties() {
        return {
          latlon: {
            type: Number,
            computed: '_latlon(weatherLocation)'
          },

          place: {
            type: Number,
            computed: '_place(weatherLocation)'
          },

          weatherLocation: {
            type: Object,
            observer: '_newLocation'
          },

          /**
           * Example:
           * {
           *  temperature: '6,5'
           * }
           */
          weatherNowData: {
            type: Object,
            notify: true
          },

          /**
           * Example:
           * {
           *  time: '2018-01-07T10:00:00Z',
           *  temperature: 6
           * }, 
           * {...}
           */
          weatherData: {
            type: Array,
            notify: true
          },
        };
      }

      ready() {
        super.ready();
      }

      _latlon (location) {
        return location.latlon; 
      }

      _place (location) {
        return location.place; 
      }

      _newLocation() {
        this.$.weather.params = this._getParams(this.weatherLocation);
        this.$.weather.generateRequest();
      }

      _getParams(location){

        let params = 
        {
          "request":"getFeature", 
          "storedquery_id":"fmi::forecast::hirlam::surface::point::timevaluepair",
          /*"place": "espoo",*/
          /*"latlon": this.locationLatlon,*/
          "parameters": "Temperature,WeatherSymbol3,Precipitation1h",
          "starttime": this._todayFirstHour(),
          "endtime": this._tomorrowLastHour()
        
        }
        
        location.place == null 
          ? params.latlon = location.latlon
          : params.place = location.place
      

        return params;
      }

      /**
       * Data is in the following format:
       *	...
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-Temperature">
			 *		<wml2:point>
		 	 *			<wml2:MeasurementTVP>
			 *				<wml2:time>2018-01-09T20:00:00Z</wml2:time>
			 *				<wml2:value>-2.41</wml2:value>
       *  ...
       *  <wml2:MeasurementTimeseries gml:id="mts-1-1-WeatherSymbol3">
			 *		<wml2:point>
			 *			<wml2:MeasurementTVP>
			 *				<wml2:time>2018-01-09T20:00:00Z</wml2:time>
			 *				<wml2:value>3.0</wml2:value>
       *  ....
       *
       * <wml2:MeasurementTimeseries gml:id="mts-1-1-Precipitation1h">
			 *		<wml2:point>
			 *			<wml2:MeasurementTVP>
			 *				<wml2:time>2018-01-23T19:00:00Z</wml2:time>
			 *			    <wml2:value>0.1</wml2:value>
       *
       */
      _handleResponse(event, request) {
        const place = this._parseLocation(request);
      
        var event = new CustomEvent('saa-data.new-place', {detail: { place: place}, bubbles: true, composed: true});
        this.dispatchEvent(event);

      
        const results = request.response.getElementsByTagName('wml2:MeasurementTimeseries');
        
        const temperatures = this._getByAttributeValue(results, 'gml:id', 'mts-1-1-Temperature');
        const symbols = this._getByAttributeValue(results, 'gml:id', 'mts-1-1-WeatherSymbol3');
        const rain = this._getByAttributeValue(results, 'gml:id', 'mts-1-1-Precipitation1h');

        const temperatureKeyValues = temperatures.getElementsByTagName('wml2:MeasurementTVP');
        const symbolKeyValues = symbols.getElementsByTagName('wml2:MeasurementTVP');
        const rainKeyValues = rain.getElementsByTagName('wml2:MeasurementTVP');

        const parsedTemps = this._parseTemperatures(temperatureKeyValues);
        const parsedSymbols = this._parseSymbols(symbolKeyValues);
        const parsedRains = this._parseKeyValues(rainKeyValues, "rain");

        const tempsAndSymbols = _.intersectionWith(parsedTemps, parsedSymbols, function(x, y) {
          return x.time === y.time && _.assign(x, y);
        });

        this.weatherData = _.intersectionWith(parsedRains, tempsAndSymbols, function(x, y) {
          return x.time === y.time && _.assign(x, y);
        });
        
        let _this = this;
        this.weatherData.forEach(function (element) {
          element.hour = _this._toHour(element.time);
        });
        this.weatherNowData = this._getWeatherNow(this.weatherData)[0];
      }

      _getByAttributeValue(collection, attribute, value) {
        for (let item of collection) {
          if(item.getAttribute(attribute) === value){
            return item;
          }
        }
      }

      _getWeatherNow(data) {
        let timeNow = new Date();
        timeNow.setMinutes(0,0,0);
        
        const timeISO = timeNow.toISOString().split('.')[0]+"Z";

        return data.filter(function (item) {
          return item.time === timeISO;
        });
      }

      _parseWeatherNow(temperatures, symbols){
        const temperatureRaw = temperatures[0].children[1].childNodes[0].nodeValue;
        const temperature = temperatureRaw;

        const symbol = Math.round(symbols[0].children[1].childNodes[0].nodeValue);

        const weatherNow = {
          temperature: temperature,
          symbol: symbol
        };

        return weatherNow;
      }

      _parseSymbols(symbols){
        let weatherData = [];
        
        weatherData = this._fillEmptyDataForSymbols(weatherData, this._toHour(symbols[0].children[0].childNodes[0].nodeValue));
        
        for (let item of symbols) {
          const hour = item.children[0].childNodes[0].nodeValue;
          const symbol = Math.round(item.children[1].childNodes[0].nodeValue);
  
            weatherData.push(
              { 
                "time": hour,
                "symbol": symbol
              }
            );
        };

        return weatherData;
      }

      _parseTemperatures(temperatures) {
        let weatherData = [];
        
        weatherData = this._fillEmptyData(weatherData, this._toHour(temperatures[0].children[0].childNodes[0].nodeValue));

        for (let item of temperatures) {
          const hour = item.children[0].childNodes[0].nodeValue;
          const temperature = parseFloat(item.children[1].childNodes[0].nodeValue);

          weatherData.push(
            { 
              "time": hour,
              "temperature": temperature
            }
          );
        };

        return weatherData;
      }

      _parseKeyValues(keyValues, name) {
        let weatherData = [];
        
        weatherData = this._fillEmptyData(weatherData, this._toHour(keyValues[0].children[0].childNodes[0].nodeValue));

        for (let item of keyValues) {
          const time = item.children[0].childNodes[0].nodeValue;
          const value = parseFloat(item.children[1].childNodes[0].nodeValue);

          weatherData.push(
            { 
              "time": time,
              "rain": value
            }
          );
        };

        return weatherData;
      }

      _fillEmptyData(weatherData, hour) {
        
        for (let i = 1; i < hour; i++) {
          weatherData.push(
            {
              "time": i,
              "temperature": ""
            }
          )
        }
        return weatherData;
      }

      _fillEmptyDataForSymbols(weatherData, hour) {
        
        for (let i = 1; i < hour; i++) {
          weatherData.push(
            {
              "time": i,
              "symbol": ""
            }
          )
        }
        return weatherData;
      }


      _toHour(time){
        
        if (typeof time === 'number'){
          return time;
        }

        const dateObject = new Date(time);
        let hour = dateObject.getHours(); 
          
        return hour === 0 ? 24 : dateObject.getHours();
      }

      _todayFirstHour() {
        
        let firstHour = new Date();
        firstHour.setHours(1,0,0,0);

        return firstHour.toISOString();
      }
      
      _tomorrowLastHour() {
        const now = new Date();

        let tomorrow = new Date()
        tomorrow.setDate(now.getDate() + 2);
        tomorrow.setHours(24,0,0,0);

        return tomorrow.toISOString();
      }

      /* <gml:name codeSpace="http://xml.fmi.fi/namespace/locationcode/name">Kattilalaakso</gml:name> */
      _parseLocation(request){
        const locations = request.response.getElementsByTagName('gml:name');

        const locationRow = this._getByAttributeValue(locations, 'codeSpace', 'http://xml.fmi.fi/namespace/locationcode/name');
        const location = locationRow.childNodes[0].nodeValue;

        return location;
      }

    }

    window.customElements.define(SaaData.is, SaaData);
  </script>
</dom-module>
